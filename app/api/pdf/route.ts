// üöÄ Nova PDF Engine V7 ‚Äî Apple Style + GPT-5 Report + Auto-height + Persona + Emotional Curve + i18n
export const runtime = "nodejs"
export const preferredRegion = "home"
export const dynamic = "force-dynamic"

import { type NextRequest, NextResponse } from "next/server"
import PDFDocument from "pdfkit"
import { supabaseAdmin } from "@/lib/supabaseAdmin"
import SVGtoPDF from "svg-to-pdfkit"
import path from "path"
import fs from "fs"

const ROBOTO_PATH = path.join(process.cwd(), "public/fonts/Roboto-VariableFont_wdth,wght.ttf")
const ROBOTO_FONT = fs.readFileSync(ROBOTO_PATH)

const OPENAI_API_KEY = process.env.OPENAI_API_KEY || ""

const I18N: Record<string, any> = {
  en: {
    report_title: "Interview Report",
    persona_profile: "NOVA Persona Profile",
    primary_persona: "Primary Persona",
    secondary_persona: "Secondary Persona",
    behavioral_mirror: "Behavioral Mirror",
    strengths: "Strengths",
    risks: "Points of Vigilance",
    emotional_trajectory: "Emotional & Communication Profile",
    stress_curve: "Stress Level Throughout Interview",
    confidence_curve: "Confidence Level Throughout Interview",
    gap_analysis: "Gap Analysis ‚Äî Answers vs Expectations",
    key_gaps: "Key Gaps",
    advice: "Nova's Advice",
    transformation_plan: "7-Day Transformation Plan",
    micro_habits: "Micro-habits to Install",
    day_plan: "Day-by-Day Plan",
    pitch_short: "Improved Pitch (Short)",
    pitch_long: "Improved Pitch (Long)",
    cv_fit: "CV & Offer Fit",
    global_fit: "Global Fit Score",
    strong_alignments: "Strong Alignments",
    potential_gaps: "Potential Gaps",
    recommendations: "Nova's Recommendations",
    behavioral_overview: "Behavioral Overview",
    communication_scores: "Global Communication Scores",
    q_title: (i: number, score?: number) => `Q${i}${score ? ` ‚Ä¢ Score: ${score}/100` : ""}`,
    question: "Question",
    followup: "Nova Follow-Up",
    answer: "Answer",
    clarify_answer: "After Clarification",
    axes: "Axes (per question)",
    expected_answer: "Expected Ideal Answer",
    improvement_score: "Improvement Score",
    case_performance: "Case Study Performance",
    your_answer: "Your Answer",
    expected_approach: "Expected Approach",
    final_feedback: "Final Interview Feedback",
    summary: "Summary",
    detailed_feedback: "Detailed Feedback",
    improvement_axes: "Key Improvement Axes",
    transcript: "Full Transcript (Cleaned)",
    footer: "Generated by Nova ‚Äî AI Interview Coach",
    question_by_question: "Question-by-Question Feedback",
  },

  fr: {
    report_title: "Rapport d'entretien",
    persona_profile: "Profil Persona Nova",
    primary_persona: "Persona principale",
    secondary_persona: "Persona secondaire",
    behavioral_mirror: "Reflet comportemental",
    strengths: "Forces",
    risks: "Points de vigilance",
    emotional_trajectory: "Profil √©motionnel et de communication",
    stress_curve: "Niveau de stress pendant l'entretien",
    confidence_curve: "Niveau de confiance pendant l'entretien",
    gap_analysis: "Analyse des √©carts ‚Äî R√©ponses vs Attentes",
    key_gaps: "√âcarts principaux",
    advice: "Conseils de Nova",
    transformation_plan: "Plan de transformation en 7 jours",
    micro_habits: "Micro-habitudes √† installer",
    day_plan: "Plan jour par jour",
    pitch_short: "Pitch am√©lior√© (court)",
    pitch_long: "Pitch am√©lior√© (long)",
    cv_fit: "Ad√©quation CV & Offre",
    global_fit: "Score global d'ad√©quation",
    strong_alignments: "Points fortement align√©s",
    potential_gaps: "Points d'alerte",
    recommendations: "Recommandations",
    behavioral_overview: "Vue comportementale",
    communication_scores: "Scores de communication globale",
    q_title: (i: number, score?: number) => `Q${i}${score ? ` ‚Ä¢ Score : ${score}/100` : ""}`,
    question: "Question",
    followup: "Relance Nova",
    answer: "R√©ponse",
    clarify_answer: "Apr√®s clarification",
    axes: "Axes (par question)",
    expected_answer: "R√©ponse id√©ale attendue",
    improvement_score: "Score d'am√©lioration",
    case_performance: "Performance √©tude de cas",
    your_answer: "Votre r√©ponse",
    expected_approach: "Approche attendue",
    final_feedback: "Retour final d'entretien",
    summary: "R√©sum√©",
    detailed_feedback: "Retour d√©taill√©",
    improvement_axes: "Axes d'am√©lioration",
    transcript: "Transcription compl√®te (nettoy√©e)",
    footer: "G√©n√©r√© par Nova ‚Äî Coach d'entretien IA",
    question_by_question: "Retour question par question",
  },
}

const REPORT_SYSTEM_PROMPT = `
You are Nova, an AI interview coach.
You receive structured data from an interview session (metrics, Q/A, emotions).
You must output a SHORT, HIGH-IMPACT 4-page report in JSON.

IMPORTANT:
- Output ONLY valid JSON.
- No markdown, no extra text, no comments.
- Respect this exact shape:

{
  "page1": {
    "behavioral_mirror": string,
    "persona": {
      "primary": "Analytical" | "Storyteller" | "Executor" | "Leader" | "Adaptive",
      "secondary": "Analytical" | "Storyteller" | "Executor" | "Leader" | "Adaptive",
      "description": string
    },
    "strengths": string[],
    "risks": string[]
  },
  "page2": {
    "gaps": string[],
    "advice": string[]
  },
  "page3": {
    "micro_habits": string[],
    "day7_plan": string[],
    "improved_pitch_short": string,
    "improved_pitch_long": string
  },
  "page4": {
    "cv_offer_fit_score": number,
    "alignment_points": string[],
    "mismatch_points": string[],
    "recommendations": string[]
  }
}

Language:
- All text must be in English only.

Tone:
- Short, clear, professional, like a senior coach.
- Use pragmatic, concrete sentences.
`

/* ---------------- Handler ---------------- */
export async function POST(req: NextRequest) {
  try {
    const { sessionId, lang = "en" } = (await req.json()) as { sessionId?: string; lang?: string }
    if (!sessionId) return NextResponse.json({ error: "Missing sessionId" }, { status: 400 })

    const L = I18N[lang] || I18N["en"]

    /* 1Ô∏è‚É£ Load session data */
    const { data: session } = await supabaseAdmin
      .from("nova_sessions")
      .select(
        `
        id,user_id,type_entretien,started_at,lang,
        score_global,
        clarity_overall,structure_overall,communication_overall,confidence_overall,
        axes_improvement,summary_json,
        final_feedback_summary,final_feedback_text,final_feedback_axes,
        transcript_full,
        duration, duration_target, total_questions, behavior_summary
      `,
      )
      .eq("id", sessionId)
      .maybeSingle()

    if (!session) return NextResponse.json({ error: "Session not found" }, { status: 404 })

    const { data: profile } = await supabaseAdmin
      .from("profiles")
      .select("prenom,nom")
      .eq("id", session.user_id)
      .maybeSingle()

    /* 2Ô∏è‚É£ Emotions brutes (pour radar global) */
    const { data: emotions } = await supabaseAdmin
      .from("nova_emotions")
      .select(
        "stress, confidence, eye_contact, posture_score, hesitations, words_per_min, authenticity_score, gaze_stability",
      )
      .eq("session_id", sessionId)

    /* 3Ô∏è‚É£ Memory (tour par tour) */
    const { data: memoryRows } = await supabaseAdmin
      .from("nova_memory")
      .select(
        `
        id,question_id,
        answer_first,answer_second,reponse,
        feedback, score, improvement_score,
        clarity_followup_used,
        scoring_axes,
        expected_answer_used,
        duration_ms, pauses_count,
        speaking_speed_wpm, hesitations_count,
        stress_score, confidence_score, eye_contact_score, posture_score,
        emotions_snapshot,
        tag, created_at
      `,
      )
      .eq("session_id", sessionId)
      .order("created_at", { ascending: true })

    /* 4Ô∏è‚É£ Questions metadata (incl. expected_answer) */
    const qIds = (memoryRows || []).map((r) => r.question_id).filter(Boolean)
    let qMap: Record<string, any> = {}
    if (qIds.length) {
      const { data: qRows } = await supabaseAdmin
        .from("nova_questions")
        .select(
          `
          question_id,
          question_en, question_fr,
          expected_answer_en, expected_answer_fr, expected_answer,
          ideal_answer,
          category, case_id,
          domain, sub_domain, tags, role_targets, expected_scope
        `,
        )
        .in("question_id", qIds)

      qMap = Object.fromEntries((qRows || []).map((q) => [q.question_id, q]))
    }

    /* 5Ô∏è‚É£ Compute Behavioral Metrics (Radar 6 axes) */
    const clarity = session.clarity_overall != null ? clamp(session.clarity_overall) : 75
    const structure = session.structure_overall != null ? clamp(session.structure_overall) : 75
    const confidence = session.confidence_overall != null ? clamp(session.confidence_overall) : 75

    const stressRaw = avg((emotions || []).map((e) => Number(e.stress) || 0))
    const eyeContact = clamp(avg((emotions || []).map((e) => Number(e.eye_contact) || 0)) * 100)
    const posture = clamp(avg((emotions || []).map((e) => Number(e.posture_score) || 0)) * 100)

    // On inverse le stress pour le radar (0 stress = 100)
    const stress = clamp(100 - stressRaw * 100)

    const radarValues = {
      Clarity: clarity,
      Structure: structure,
      Confidence: confidence,
      EyeContact: eyeContact,
      Stress: stress,
      Posture: posture,
    }

    const scoreGlobal = clamp(session.score_global ?? avg([clarity, structure, confidence, eyeContact, posture]))

    /* 6Ô∏è‚É£ Init PDF */
    const doc = new PDFDocument({ size: "A4", margin: 46 })

    const chunks: Buffer[] = []
    doc.on("data", (c: Buffer) => chunks.push(c))

    doc.registerFont("NovaFont", ROBOTO_FONT)
    doc.font("NovaFont")

    /* ---------- Colors / Meta ---------- */
    const BLUE = "#0A5CFF"
    const TEXT = "#1D1D1F"
    const DARK = "#000000"
    const LIGHT_GRAY = "#F5F5F7"
    const fullName = `${safe(profile?.prenom)} ${safe(profile?.nom)}`.trim() || "Candidate"
    const dateStr = new Date(session?.started_at || new Date()).toLocaleDateString("en-US", {
      year: "numeric",
      month: "long",
      day: "numeric",
    })

    /* ---------- COVER PAGE ---------- */
    const grad = doc.linearGradient(0, 0, 0, 842)
    grad.stop(0, "#020617").stop(1, "#000000")
    doc.rect(0, 0, 595, 842).fill(grad)

    const logoUrl =
      "https://qpnalviccuopdwfscoli.supabase.co/storage/v1/object/public/nova-assets/talentee_logo_static.svg"
    let logoSVG: string | null = null
    try {
      const r = await fetch(logoUrl)
      logoSVG = await r.text()
    } catch {
      // ignore
    }

    if (logoSVG) {
      SVGtoPDF(doc as any, logoSVG, 222, 120, { width: 150, assumePt: true })
    }

    doc
      .fillColor("#FFF")
      .fontSize(30)
      .text(L.report_title, 0, 300, { align: "center" })
      .fontSize(16)
      .fillColor("#C3D5FF")
      .text(`${fullName}`, 0, 350, { align: "center" })
      .fontSize(13)
      .text(dateStr, 0, 380, { align: "center" })
      .moveDown(3)
      .fontSize(11)
      .fillColor("#94A3B8")
      .text("Nova ‚Äî AI Interview Coach", { align: "center" })

    doc
      .fillColor("#64748B")
      .fontSize(10)
      .text(`Session type: ${safe(session.type_entretien || "Interview")} ‚Ä¢ Global score: ${scoreGlobal}/100`, 0, 430, {
        align: "center",
      })

    /* ---------- PAGE 2: PERSONA PROFILE ---------- */
    doc.addPage()
    doc.rect(0, 0, 595, 842).fill("#F5F5F7")
    doc.rect(0, 0, 595, 100).fill("#FFF")
    doc.fillColor("#0A5CFF").fontSize(24).text(L.persona_profile, 46, 50)

    let py = 140

    const personaLabels: Record<string, string> = {
      "Strategic Leader": "Decisive, structured communication with strong executive presence.",
      "Analytical Thinker": "Clear reasoning, structured analysis, and high precision.",
      "Story-Driven Communicator": "Engaging narrative-driven communication with emotional resonance.",
      "Adaptive Problem Solver": "Flexible, agile thinking with rapid context switching.",
      "Practical Implementer": "Hands-on, reliable execution-focused communicator.",
      Analytical: "Clear reasoning, structured analysis, and high precision.",
      Storyteller: "Engaging narrative-driven communication with emotional resonance.",
      Executor: "Hands-on, reliable execution-focused communicator.",
      Leader: "Decisive, structured communication with strong executive presence.",
      Adaptive: "Flexible, agile thinking with rapid context switching.",
    }

    const qaPairs =
      (memoryRows || []).slice(0, 30).map((m: any) => ({
        question_id: m.question_id,
        answer: m.answer_second || m.answer_first || m.reponse || "",
        expected: extractExpectedAnswer(qMap[m.question_id] || {}, lang),
        score: m.score ?? null,
      })) || []

    const gptInput = {
      lang,
      candidate: {
        prenom: profile?.prenom || "",
        nom: profile?.nom || "",
      },
      session: {
        id: session.id,
        type_entretien: session.type_entretien,
        score_global: scoreGlobal,
        clarity_overall: clarity,
        structure_overall: structure,
        communication_overall: session.communication_overall,
        confidence_overall: confidence,
        behavior_summary: session.behavior_summary,
        final_feedback_summary: session.final_feedback_summary,
        final_feedback_text: session.final_feedback_text,
        final_feedback_axes: session.final_feedback_axes,
        duration: session.duration,
        total_questions: session.total_questions,
      },
      behavior_metrics: radarValues,
      emotions: emotions || [],
      qa_pairs: qaPairs,
      transcript: session.transcript_full || "",
    }

    let report: any = null

    if (OPENAI_API_KEY) {
      try {
        const res = await fetch("https://api.openai.com/v1/chat/completions", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${OPENAI_API_KEY}`,
          },
          body: JSON.stringify({
            model: "gpt-4",
            response_format: { type: "json_object" },
            messages: [
              { role: "system", content: REPORT_SYSTEM_PROMPT },
              { role: "user", content: JSON.stringify(gptInput) },
            ],
          }),
        })

        if (res.ok) {
          const body = await res.json()
          const content = body?.choices?.[0]?.message?.content
          if (content) {
            report = JSON.parse(content)
          }
        }
      } catch (e) {
        console.error("GPT call exception:", e)
      }
    }

    if (!report) {
      report = {
        page1: {
          behavioral_mirror:
            "You came across as clear and composed, with a slightly fast pace at times. Your overall presence is calm and structured.",
          persona: {
            primary: "Analytical",
            secondary: "Executor",
            description:
              "You like to structure ideas, go straight to the point, and quickly turn decisions into concrete actions.",
          },
          strengths: ["Clarity", "Calm", "Structure", "Analytical mindset"],
          risks: ["Sometimes too fast", "Limited storytelling", "Business impact not always explicit"],
        },
        page2: {
          gaps: [
            "Answers describe actions but often miss quantified results.",
            "The structure is not always announced upfront.",
          ],
          advice: [
            "Slow your pace to let your message land.",
            "Announce your structure in one sentence before you dive into details.",
            "End each answer with a clear, measurable result.",
          ],
        },
        page3: {
          micro_habits: [
            "Take one breath before answering to ground your voice.",
            "Mentally formulate your main idea in one sentence before speaking.",
            "End each answer with a clear result.",
          ],
          day7_plan: [
            "Day 1 ‚Äì Rewrite 3 answers using a simple structure (context, action, result).",
            "Day 2 ‚Äì Practice speaking slower by reading a text out loud.",
            "Day 3 ‚Äì Prepare a 20-second pitch and repeat it 5 times.",
            "Day 4 ‚Äì Add one key metric to three of your answers.",
            "Day 5 ‚Äì Practice eye contact in front of a mirror for 5 minutes.",
            "Day 6 ‚Äì Record yourself on 2 questions and listen back critically.",
            "Day 7 ‚Äì Run a 10-minute mock interview applying all improvements.",
          ],
          improved_pitch_short:
            "I am an analytical, results-driven professional who quickly clarifies key issues and proposes concrete action plans.",
          improved_pitch_long:
            "I am an analytical, results-driven profile used to demanding environments. I quickly understand challenges, structure priorities, and implement concrete actions with clear KPIs. My focus is always on measurable impact, while staying close to the team and stakeholders. I now want to bring this approach to an ambitious organization.",
        },
        page4: {
          cv_offer_fit_score: 70,
          alignment_points: ["Overall experience aligned with the target role."],
          mismatch_points: [
            "Quantified impact not clearly visible in the resume.",
            "Few explicit leadership examples.",
          ],
          recommendations: [
            "Add 1‚Äì2 key metrics per major experience.",
            "Highlight at least one strong leadership or project ownership example.",
            "Align your wording with the job description keywords.",
          ],
        },
      }
    }

    const p1 = report.page1

    if (py > 700) {
      doc.addPage()
      py = 60
    }

    py = block(
      doc,
      L.primary_persona,
      `${p1.persona.primary}: ${personaLabels[p1.persona.primary] || p1.persona.description}`,
      py,
    )

    if (py > 700) {
      doc.addPage()
      py = 60
    }

    py = block(
      doc,
      L.secondary_persona,
      `${p1.persona.secondary}: ${personaLabels[p1.persona.secondary] || "Complementary profile"}`,
      py,
    )

    if (py > 700) {
      doc.addPage()
      py = 60
    }

    py = block(doc, L.behavioral_mirror, p1.behavioral_mirror, py)

    if (py > 700) {
      doc.addPage()
      py = 60
    }

    doc.fillColor("#0A5CFF").fontSize(12).text(L.strengths, 46, py)
    py += 20

    const strengthsText = (p1.strengths || []).map((s: string) => "‚Ä¢ " + s).join("\n")
    py += writeBlock(doc, strengthsText, 60, py) + 20

    if (py > 700) {
      doc.addPage()
      py = 60
    }

    doc.fillColor("#0A5CFF").fontSize(12).text(L.risks, 46, py)
    py += 20

    const risksText = (p1.risks || []).map((r: string) => "‚Ä¢ " + r).join("\n")
    py += writeBlock(doc, risksText, 60, py) + 30

    /* ---------- PAGE 3: EMOTIONAL TRAJECTORY ---------- */
    doc.addPage()
    doc.rect(0, 0, 595, 842).fill("#F5F5F7")
    doc.rect(0, 0, 595, 100).fill("#FFF")
    doc.fillColor("#0A5CFF").fontSize(24).text("Emotional & Communication Profile", 46, 50)

    // Extraire les donn√©es √©motionnelles depuis la m√©moire
    const memory = (memoryRows || [])[0] // Prendre la premi√®re entr√©e comme exemple
    const emo = memory?.emotions_snapshot || {}

    const stressLevel = clamp01(emo.stress)
    const confidenceLevel = clamp01(emo.confidence)
    const eyeContactLevel = clamp01(emo.eye_contact)
    const postureLevel = clamp01(emo.posture_score)
    const gazeLevel = clamp01(emo.gaze_stability)

    const fluency = {
      hesitations: emo.hesitations ?? null,
      pauses: emo.pauses_count ?? null,
      wpm: emo.words_per_min ?? null,
    }

    let ey = 130

    // Bloc visuel - Stress level
    doc
      .fillColor("#1D1D1F")
      .fontSize(12)
      .text(`Stress level: ${pct(stressLevel)}`, 46, ey)
    ey += 20
    progressBar(doc, stressLevel, 46, ey)
    ey += 35

    // Confidence
    doc
      .fillColor("#1D1D1F")
      .fontSize(12)
      .text(`Confidence: ${pct(confidenceLevel)}`, 46, ey)
    ey += 20
    progressBar(doc, confidenceLevel, 46, ey)
    ey += 45

    // Radar Chart
    doc.fillColor("#1D1D1F").fontSize(14).text("Non-verbal communication profile:", 46, ey)
    ey += 25
    drawRadarChart(
      doc,
      {
        eye_contact: eyeContactLevel,
        posture: postureLevel,
        gaze_stability: gazeLevel,
      },
      46,
      ey,
    )
    ey += 200

    // Fluency indicators
    doc
      .fillColor("#1D1D1F")
      .fontSize(12)
      .text(`Speaking speed (wpm): ${fluency.wpm ?? "‚Äî"}`, 46, ey)
    ey += 20
    doc.text(`Hesitations: ${fluency.hesitations ?? "‚Äî"}`, 46, ey)
    ey += 20
    doc.text(`Pauses count: ${fluency.pauses ?? "‚Äî"}`, 46, ey)

    /* ---------- PAGE 4: GAP ANALYSIS ---------- */
    const p2 = report.page2

    doc.addPage()
    doc.rect(0, 0, 595, 842).fill("#F5F5F7")
    doc.rect(0, 0, 595, 100).fill("#FFF")
    doc.fillColor("#0A5CFF").fontSize(24).text(L.gap_analysis, 46, 50)

    let gy = 130

    if (gy > 700) {
      doc.addPage()
      gy = 60
    }

    doc.fillColor("#1D1D1F").fontSize(13).text(L.key_gaps, 46, gy)
    gy += 25

    const gapsText = (p2.gaps || []).map((g: string) => "‚Ä¢ " + g).join("\n")
    gy += writeBlock(doc, gapsText, 60, gy) + 20

    if (gy > 700) {
      doc.addPage()
      gy = 60
    }

    doc.fillColor("#1D1D1F").fontSize(13).text(L.advice, 46, gy)
    gy += 25

    const adviceText = (p2.advice || []).map((a: string) => "‚Ä¢ " + a).join("\n")
    gy += writeBlock(doc, adviceText, 60, gy) + 30

    /* ---------- PAGE 5: 7-DAY TRANSFORMATION PLAN ---------- */
    const p3 = report.page3

    doc.addPage()
    doc.rect(0, 0, 595, 842).fill("#020617")
    doc.fillColor("#FFFFFF").fontSize(24).text(L.transformation_plan, 46, 50)

    let mhY = 110

    doc.fillColor("#0A5CFF").fontSize(13).text(L.micro_habits, 46, mhY)
    mhY += 25

    const microHabitsText = (p3.micro_habits || []).map((m: string) => "‚Ä¢ " + m).join("\n")
    mhY += writeBlock(doc, microHabitsText, 60, mhY, 480, 10, "#E5E7EB") + 20

    if (mhY > 700) {
      doc.addPage()
      mhY = 60
    }

    doc.fillColor("#0A5CFF").fontSize(13).text(L.day_plan, 46, mhY)
    mhY += 25

    const dayPlanText = (p3.day7_plan || []).map((d: string) => "‚Ä¢ " + d).join("\n")
    mhY += writeBlock(doc, dayPlanText, 60, mhY, 480, 10, "#E5E7EB") + 30

    if (mhY > 700) {
      doc.addPage()
      mhY = 60
    }

    doc.fillColor("#0A5CFF").fontSize(13).text(L.pitch_short, 46, mhY)
    mhY += 20

    mhY += writeBlock(doc, p3.improved_pitch_short, 60, mhY, 480, 10, "#E5E7EB") + 30

    if (mhY > 700) {
      doc.addPage()
      mhY = 60
    }

    doc.fillColor("#0A5CFF").fontSize(13).text(L.pitch_long, 46, mhY)
    mhY += 20

    mhY += writeBlock(doc, p3.improved_pitch_long, 60, mhY, 480, 10, "#E5E7EB") + 30

    /* ---------- PAGE 6: CV & OFFER FIT ---------- */
    const p4 = report.page4

    doc.addPage()
    doc.rect(0, 0, 595, 842).fill("#F5F5F7")
    doc.rect(0, 0, 595, 100).fill("#FFF")
    doc.fillColor("#0A5CFF").fontSize(24).text(L.cv_fit, 46, 50)

    const fitScore = clamp(p4.cv_offer_fit_score ?? 50)

    doc.fillColor("#1D1D1F").fontSize(13).text(L.global_fit, 46, 130)
    doc.fontSize(36).fillColor("#0A5CFF").text(`${fitScore}/100`, 46, 155)

    let alY = 220

    if (alY > 700) {
      doc.addPage()
      alY = 60
    }

    doc.fillColor("#1D1D1F").fontSize(13).text(L.strong_alignments, 46, alY)
    alY += 25

    const alignmentText = (p4.alignment_points || []).map((a: string) => "‚Ä¢ " + a).join("\n")
    alY += writeBlock(doc, alignmentText, 60, alY) + 20

    if (alY > 700) {
      doc.addPage()
      alY = 60
    }

    doc.fillColor("#1D1D1F").fontSize(13).text(L.potential_gaps, 46, alY)
    alY += 25

    const mismatchText = (p4.mismatch_points || []).map((m: string) => "‚Ä¢ " + m).join("\n")
    alY += writeBlock(doc, mismatchText, 60, alY) + 20

    if (alY > 700) {
      doc.addPage()
      alY = 60
    }

    doc.fillColor("#1D1D1F").fontSize(13).text(L.recommendations, 46, alY)
    alY += 25

    const recommendationsText = (p4.recommendations || []).map((r: string) => "‚Ä¢ " + r).join("\n")
    alY += writeBlock(doc, recommendationsText, 60, alY) + 30

    /* ---------- PAGE 7+: BEHAVIORAL OVERVIEW ---------- */
    doc.addPage()
    doc.rect(0, 0, 595, 842).fill("#F5F5F7")
    doc.rect(0, 0, 595, 100).fill("#FFF")
    doc.fillColor("#0A5CFF").fontSize(24).text(L.behavioral_overview, 46, 50)

    const metrics = [
      { label: "Clarity", value: clarity },
      { label: "Structure", value: structure },
      { label: "Confidence", value: confidence },
      { label: "Eye Contact", value: radarValues.EyeContact },
      { label: "Stress Management", value: radarValues.Stress },
      { label: "Posture", value: radarValues.Posture },
    ]

    doc.rect(30, 120, 535, 200).fill("#FFF")
    let y = 140
    metrics.forEach((m) => {
      doc.fillColor("#1D1D1F").fontSize(10).text(m.label, 46, y)
      doc.rect(150, y - 4, 280, 8).fill("#E5E7EB")
      doc.rect(150, y - 4, (m.value / 100) * 280, 8).fill("#0A5CFF")
      doc
        .fillColor("#1D1D1F")
        .fontSize(9)
        .text(`${m.value}%`, 445, y - 5)
      y += 26
    })

    doc.rect(30, 340, 535, 220).fill("#FFF")
    SVGtoPDF(doc as any, radarSVG(radarValues), 335, 360, { width: 180, assumePt: true })

    doc
      .fillColor("#1D1D1F")
      .fontSize(11)
      .text(
        session.behavior_summary ||
          "Nova observed your stress, confidence, posture and eye contact throughout the interview to refine this overview.",
        46,
        360,
        { width: 260 },
      )

    doc.fillColor("#0A5CFF").fontSize(14).text(L.communication_scores, 46, 580)
    const globalScores = [
      { k: "Clarity", v: session.clarity_overall },
      { k: "Structure", v: session.structure_overall },
      { k: "Communication", v: session.communication_overall },
      { k: "Confidence", v: session.confidence_overall },
    ]
    let ys = 610
    globalScores.forEach((s) => {
      const val = clamp(s.v || 0)
      doc.fillColor("#1D1D1F").fontSize(11).text(s.k, 46, ys)
      doc.rect(150, ys - 4, 280, 8).fill("#E5E7EB")
      doc.rect(150, ys - 4, (val / 100) * 280, 8).fill("#0A5CFF")
      doc
        .fillColor("#1D1D1F")
        .fontSize(9)
        .text(`${val}%`, 445, ys - 5)
      ys += 24
    })

    /* ---------- QUESTION-BY-QUESTION FEEDBACK ---------- */
    doc.addPage()
    doc.rect(0, 0, 595, 842).fill("#F5F5F7")
    doc.rect(0, 0, 595, 100).fill("#FFF")
    doc.fillColor("#0A5CFF").fontSize(24).text(L.question_by_question, 46, 50)

    let yy = 130

    for (const [i, m] of (memoryRows || []).entries()) {
      const q = qMap[m.question_id || ""] || {}

      if (yy > 700) {
        doc.addPage()
        doc.rect(0, 0, 595, 842).fill("#F5F5F7")
        yy = 60
      }

      const cardStart = yy
      doc.rect(30, cardStart - 10, 535, 20).fill("#FFF")

      const head = L.q_title(i + 1, m.score ? clamp(m.score) : undefined)
      doc.fillColor("#0A5CFF").fontSize(12).text(head, 46, yy)
      yy += 25

      const questionText = q.question_en || q.question_fr || "Question text unavailable."
      if (yy > 700) {
        doc.addPage()
        yy = 60
      }
      yy = block(doc, L.question, questionText, yy)

      if (m.clarity_followup_used) {
        if (yy > 700) {
          doc.addPage()
          yy = 60
        }
        yy = block(doc, L.followup, m.clarity_followup_used, yy)
      }

      const firstAns = m.answer_first || m.reponse || null
      if (firstAns) {
        if (yy > 700) {
          doc.addPage()
          yy = 60
        }
        yy = block(doc, L.answer, firstAns, yy)
      }

      const secondAns = m.answer_second || null
      if (secondAns) {
        if (yy > 700) {
          doc.addPage()
          yy = 60
        }
        yy = block(doc, L.clarify_answer, secondAns, yy)
      }

      if (m.scoring_axes) {
        if (yy > 700) {
          doc.addPage()
          yy = 60
        }
        doc.fillColor("#1D1D1F").fontSize(11).text(L.axes, 46, yy)
        yy += 18
        const axes = m.scoring_axes || {}
        Object.keys(axes).forEach((k) => {
          const val = toPercentFrom0to1(axes[k])
          doc.fontSize(10).fillColor("#4B5563").text(`${k}: ${val}%`, 60, yy, { width: 480 })
          yy += 14
        })
        yy += 10
      }

      if (yy > 700) {
        doc.addPage()
        yy = 60
      }
      yy = block(doc, "Nova Feedback", m.feedback || "‚Äî", yy)

      const expected = extractExpectedAnswer(q, lang)
      if (yy > 700) {
        doc.addPage()
        yy = 60
      }
      yy = block(doc, L.expected_answer, expected, yy)

      if (m.improvement_score) {
        if (yy > 700) {
          doc.addPage()
          yy = 60
        }
        const imp = clamp(Number(m.improvement_score) * 100)
        doc.fillColor("#1D1D1F").fontSize(11).text(L.improvement_score, 46, yy)
        yy += 18
        doc.rect(60, yy, 480, 8).fill("#E5E7EB")
        doc.rect(60, yy, (imp / 100) * 480, 8).fill("#0A5CFF")
        doc
          .fillColor("#1D1D1F")
          .fontSize(9)
          .text(`${imp}%`, 555, yy - 3)
        yy += 28
      }

      yy += 20
    }

    /* ---------- CASE STUDY SECTION ---------- */
    const hasCases = Object.values(qMap).some((q: any) => q?.case_id || q?.category === "case")

    if (hasCases) {
      doc.addPage()
      doc.rect(0, 0, 595, 842).fill("#F5F5F7")
      doc.rect(0, 0, 595, 100).fill("#FFF")
      doc.fillColor("#0A5CFF").fontSize(24).text(L.case_performance, 46, 50)

      let cy = 130
      const groupedByCase: Record<string, any[]> = {}

      for (const m of memoryRows || []) {
        const q = qMap[m.question_id || ""] || {}
        const cid = q.case_id || null
        if (!cid) continue
        if (!groupedByCase[cid]) groupedByCase[cid] = []
        groupedByCase[cid].push({ q, m })
      }

      Object.keys(groupedByCase).forEach((cid) => {
        const items = groupedByCase[cid]

        if (cy > 700) {
          doc.addPage()
          doc.rect(0, 0, 595, 842).fill("#F5F5F7")
          cy = 80
        }

        doc.fillColor("#0A5CFF").fontSize(14).text(`Case ${cid}`, 46, cy)
        cy += 25

        items.forEach(({ q, m }) => {
          const qText = q?.question_en || q?.question_fr || "Case question"
          const ans = m?.answer_first || m?.reponse || "‚Äî"
          const exp = extractExpectedAnswer(q, lang)

          if (cy > 700) {
            doc.addPage()
            cy = 60
          }
          cy = block(doc, L.question, qText, cy)

          if (cy > 700) {
            doc.addPage()
            cy = 60
          }
          cy = block(doc, L.your_answer, ans, cy)

          if (cy > 700) {
            doc.addPage()
            cy = 60
          }
          cy = block(doc, L.expected_approach, exp, cy)

          cy += 20
        })

        cy += 15
      })
    }

    /* ---------- FINAL FEEDBACK ---------- */
    doc.addPage()
    doc.rect(0, 0, 595, 842).fill("#F5F5F7")
    doc.rect(0, 0, 595, 100).fill("#FFF")
    doc.fillColor("#0A5CFF").fontSize(24).text(L.final_feedback, 46, 50)

    let fy = 130

    if (fy > 700) {
      doc.addPage()
      fy = 60
    }
    fy = block(doc, L.summary, session.final_feedback_summary || "‚Äî", fy, 500)

    if (fy > 700) {
      doc.addPage()
      fy = 60
    }
    fy = block(doc, L.detailed_feedback, session.final_feedback_text || "‚Äî", fy, 500)

    if (Array.isArray(session.final_feedback_axes) && session.final_feedback_axes.length > 0) {
      if (fy > 700) {
        doc.addPage()
        fy = 60
      }
      doc.fillColor("#1D1D1F").fontSize(14).text(L.improvement_axes, 46, fy)
      fy += 25
      session.final_feedback_axes.forEach((ax: string) => {
        if (fy > 700) {
          doc.addPage()
          fy = 60
        }
        fy = block(doc, null, "‚Ä¢ " + ax, fy, 480, 16)
      })
    }

    /* ---------- FULL TRANSCRIPT ---------- */
    if (session.transcript_full) {
      doc.addPage()
      doc.rect(0, 0, 595, 842).fill("#F5F5F7")
      doc.rect(0, 0, 595, 100).fill("#FFF")
      doc.fillColor("#0A5CFF").fontSize(24).text(L.transcript, 46, 50)

      let ty = 130
      if (ty > 700) {
        doc.addPage()
        ty = 60
      }
      ty = block(doc, null, session.transcript_full, ty, 500)
    }

    /* ---------- FOOTER ---------- */
    doc.fillColor("#86868B").fontSize(9).text(L.footer, 0, 800, {
      align: "center",
    })

    /* ---------- END ---------- */
    const buffer = await new Promise<Buffer>((resolve, reject) => {
      doc.on("end", () => {
        try {
          resolve(Buffer.concat(chunks))
        } catch (err) {
          reject(err)
        }
      })
      doc.on("error", reject)
      doc.end()
    })

    return new NextResponse(buffer, {
      status: 200,
      headers: {
        "Content-Type": "application/pdf",
        "Content-Disposition": `attachment; filename="Nova_Report_${sessionId}.pdf"`,
        "Content-Length": buffer.length.toString(),
      },
    })
  } catch (err: any) {
    console.error("‚ùå Nova PDF V7 Error:", err)
    return NextResponse.json({ error: err.message || "PDF error" }, { status: 500 })
  }
}

function writeBlock(
  doc: any,
  text: string,
  x: number,
  y: number,
  w = 480,
  fontSize = 11,
  color = "#1D1D1F",
  align: any = "left",
) {
  doc.fillColor(color).fontSize(fontSize).text(text, x, y, {
    width: w,
    align,
  })

  return doc.heightOfString(text, { width: w })
}

function block(doc: any, title: string | null, text: string, y: number, width = 480, spacing = 18): number {
  if (title) {
    doc.fillColor("#0A5CFF").fontSize(11).text(title, 46, y)
    y += spacing
  }

  doc.fillColor("#1D1D1F").fontSize(11).text(text, 60, y, { width })
  const h = doc.heightOfString(text, { width })

  return y + h + spacing
}

function generateCurveSVG(points: number[], color: string): string {
  if (!points || !points.length) return "<svg></svg>"
  const w = 500,
    h = 120
  let path = `M0 ${h - points[0] * h}`
  for (let i = 1; i < points.length; i++) {
    const x = (i / (points.length - 1)) * w
    const y = h - points[i] * h
    path += ` L${x} ${y}`
  }
  return `<svg width="${w}" height="${h}" xmlns="http://www.w3.org/2000/svg">
    <path d="${path}" stroke="${color}" stroke-width="3" fill="none"/>
  </svg>`
}

function radarSVG(vals: Record<string, number>) {
  const size = 180
  const center = size / 2
  const maxRadius = size / 2 - 10

  const axes = Object.keys(vals)
  const angleStep = (2 * Math.PI) / axes.length

  let points = ""
  axes.forEach((key, i) => {
    const angle = i * angleStep - Math.PI / 2
    const value = (vals[key] || 0) / 100
    const r = value * maxRadius
    const x = center + r * Math.cos(angle)
    const y = center + r * Math.sin(angle)
    points += `${x},${y} `
  })

  return `<svg width="${size}" height="${size}" xmlns="http://www.w3.org/2000/svg">
    <polygon points="${points.trim()}" fill="#0A5CFF" fill-opacity="0.3" stroke="#0A5CFF" stroke-width="2"/>
  </svg>`
}

function extractExpectedAnswer(q: any, lang: string): string {
  if (q?.expected_answer) return String(q.expected_answer)

  if (lang === "fr" && q?.expected_answer_fr) return q.expected_answer_fr
  if (q?.expected_answer_en) return q.expected_answer_en

  if (q?.ideal_answer && typeof q.ideal_answer === "object") {
    const ia = q.ideal_answer
    if (lang === "fr" && ia.fr) return ia.fr
    if (ia.en) return ia.en
  }

  return "No ideal answer available for this question."
}

function toPercentFrom0to1(v: any): number {
  if (v == null) return 0
  const num = Number(v)
  if (!isFinite(num)) return 0
  if (num <= 1) return clamp(num * 100)
  return clamp(num)
}

function clamp(n: number, min = 0, max = 100) {
  return Math.max(min, Math.min(max, Math.round(Number(n) || 0)))
}

function avg(arr: number[]) {
  return arr.length ? arr.reduce((a, b) => a + b, 0) / arr.length : 0
}

function safe(v?: any) {
  return v == null ? "" : String(v)
}

/* ============== Helper Functions ============== */

function clamp01(val: any): number {
  const n = Number(val) || 0
  return Math.max(0, Math.min(1, n))
}

function pct(val: number): string {
  return `${Math.round(val * 100)}%`
}

function progressBar(doc: any, value: number, x = 46, y = 0, width = 480, height = 12): void {
  const barWidth = value * width
  // Background
  doc.rect(x, y, width, height).fill("#E5E7EB")
  // Foreground
  doc.rect(x, y, barWidth, height).fill("#0A5CFF")
}

function drawRadarChart(
  doc: any,
  values: { eye_contact: number; posture: number; gaze_stability: number },
  x = 46,
  y = 0,
): void {
  const size = 180
  const center = size / 2
  const maxRadius = size / 2 - 10

  const axes = [
    { label: "Eye Contact", value: values.eye_contact },
    { label: "Posture", value: values.posture },
    { label: "Gaze", value: values.gaze_stability },
  ]

  const angleStep = (2 * Math.PI) / axes.length

  // Cr√©er le SVG du radar
  let points = ""
  axes.forEach((axis, i) => {
    const angle = i * angleStep - Math.PI / 2
    const r = axis.value * maxRadius
    const px = center + r * Math.cos(angle)
    const py = center + r * Math.sin(angle)
    points += `${px},${py} `
  })

  const radarSVG = `<svg width="${size}" height="${size}" xmlns="http://www.w3.org/2000/svg">
    <circle cx="${center}" cy="${center}" r="${maxRadius}" fill="none" stroke="#E5E7EB" stroke-width="1"/>
    <circle cx="${center}" cy="${center}" r="${maxRadius * 0.66}" fill="none" stroke="#E5E7EB" stroke-width="1"/>
    <circle cx="${center}" cy="${center}" r="${maxRadius * 0.33}" fill="none" stroke="#E5E7EB" stroke-width="1"/>
    <polygon points="${points.trim()}" fill="#0A5CFF" fill-opacity="0.3" stroke="#0A5CFF" stroke-width="2"/>
  </svg>`

  SVGtoPDF(doc as any, radarSVG, x, y, { width: size, assumePt: true })
}
